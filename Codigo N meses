using Gurobi
using JuMP, Gurobi, Plots, HiGHS 

# Dados
custos = [8, 12, 15, 18]
v0 = 40
pot_max = [10, 15, 20, 15]
num_mes = 3
num_termicas = 4
num_hidreletricas = 1
num_cenarios = 1
# CH = [0 5 ; 0 5]  
CH = [0, 5]
# print(CH)
demanda = 50

function primeiro_mes(num_cortes, fmi, λ, vs, custos, demanda, num_hidreletricas, num_termicas, pot_max, v0, num_cenarios)
    modelo = Model(Gurobi.Optimizer)

    @variable(modelo, 0 <= termicas[1, j = 1:num_termicas] <= pot_max[j])
    @variable(modelo, 0 <= hidreletrica[1, 1])
    @variable(modelo, 0 <= volume[1, 1])
    @variable(modelo, Z >= 0)

    @constraint(modelo, sum(termicas[1, j] for j in 1:num_termicas) + sum(hidreletrica[1, 1]) == demanda)
    @constraint(modelo, volume[1, 1] == v0 - hidreletrica[1, 1])
    print(num_cortes)
    for e ∈ 1:num_cortes
        Z_cenario = 0.0
        for k in 1:num_cenarios
            Z_cenario += (fmi[e, k] + λ[e, k] * (volume[1, 1] - vs[e])) 
        end
        @constraint(modelo, Z >= (Z_cenario/num_cenarios))
    end

    @objective(modelo, Min, sum(custos[j] * termicas[1, j] for j in 1:num_termicas) + Z)
    print(modelo)

    optimize!(modelo)
    return value(volume[1, 1]), objective_value(modelo), value(Z)
end

function meses_seguintes(volume_antigo,fmi, λ, num_cortes,mes_novo,chuva, num_termicas, num_hidreletricas, custos, demanda, pot_max)
    modelo = Model(Gurobi.Optimizer)

    @variable(modelo, 0 <= termicas_i[mes_novo, j = 1:num_termicas] <= pot_max[j])
    @variable(modelo, hidreletrica_i[mes_novo, 1:num_hidreletricas] >= 0)
    @variable(modelo, volume_i[mes_novo,1:num_hidreletricas] >= 0)
    

    @constraint(modelo, sum(termicas_i[mes_novo,j] for j in 1:num_termicas) + hidreletrica_i[mes_novo,1] == demanda)

    global rest = @constraint(modelo, volume_i[mes_novo,1] == volume_antigo - hidreletrica_i[mes_novo,1] + chuva)
    
    #Restrição Z
    for k in 1:num_cortes
        @constraint(modelo, Z >= λ[mes_novo,k]*(volume_i[mes_novo,1]-vs[mes_novo,k])+fmi[mes_novo,i])
    end

   # readline()
    @objective(modelo, Min, sum(custos[j] * termicas_i[mes_novo,j] for j in 1:num_termicas))
    print(modelo)  
    optimize!(modelo)
    status = termination_status(modelo)
    local λ_novo 
    λ_novo = dual(rest)
    println(λ_novo)
    return λ_novo, objective_value(modelo)
end

function resolve_problema_todo(custos, demanda, num_hidreletricas, num_termicas, pot_max, num_mes, v0, num_cenarios)
    m = num_mes
    n = num_cenarios
    fmi_cont = -100.0 
    Z = rand()*10e5
    Z_vet = []
    vs = zeros(m,1) #v estrela (volume no final do mês 1 com um certo ve passado)
    # vs = Array{Float64}(undef,m,n)
    # fmi = zeros(Float64, m, num_cenarios) #valor do custo em cada mês
    # fmi = [0; 0; 0] #valor do custo em cada mês
    fmi = zeros(m,1)
    # fmi = hcat(fmi,[3,4,5])
    # print(fmi)
    # sleep(10)
    # λ = zeros(Float64, 0, num_cenarios) 
    λ = zeros(m,1)  
  
    num_cortes = 0

    while abs(fmi_cont - Z) > 1e-6
        saidas1 = primeiro_mes(num_cortes, fmi, λ, vs, custos, demanda, num_hidreletricas, num_termicas, pot_max, v0, num_cenarios)
        # readline()
        global fm1 =  saidas1[2]
        vsi = saidas1[1]
        push!(vs, vsi)
        Z = saidas1[3]
        push!(Z_vet, Z)
        println("Saídas do Primeiro Mês:")
        println("Volume Final: ", saidas1[1])
        println("Custo Total: ", saidas1[2])
        println("Z : ", saidas1[3])
        println()
        #readline()
        fmi_novo = zeros(Float64, num_mes, num_cenarios)
        λ_novo = zeros(Float64, num_mes, num_cenarios)
        readline()
        #saidas = zeros(num_cenarios)
        for mes_novo in 2:num_mes
            for k in 1:num_cenarios
                saidas2 = meses_seguintes(vs, fmi, λ,num_cortes,mes_novo,CH[k], num_termicas, num_hidreletricas, custos, demanda, pot_max)
                fmi_novo[mes_novo, k] = saidas2[2]
                λ_novo[mes_novo, k] = saidas2[1]
                # push!(matriz_Z, Z_vet)
                println("Saídas do Mês $mes_novo para o cenário $k:")
                println("Multiplicadores de Lagrange $k (λ): ", saidas2[1])
                println("Custo Total: ", saidas2[2])
                println()
            #   print("\n Valor da função do mes 2 int $k \n ", fmi_novo)
            end
        end

        fmi = vcat(fmi, fmi_novo)
      #  print("\n Valor da função do mes $mes_atual \n ", fm2)

        λ = vcat(λ, λ_novo)
        # fm2_cont = fm2_novo[1, 1]
        fmi_cont = sum(fmi_novo)/num_cenarios
       # print("\n Valor da função do mes $mes_atual \n ", fmi_cont)
        num_cortes += 1
      #  readline()
      global fm1 =  saidas1[2]
    end

    return Z, fmi, vs, λ,fm1
end

saidas3 = resolve_problema_todo(custos, demanda, num_hidreletricas, num_termicas, pot_max, mes, v0, num_cenarios)
println("Resultado Final:")
println("Custo Total: ", saidas3[5] )
println("Z: ", saidas3[1])
println("fmi: ", saidas3[2])
println("vs: ", saidas3[3])

println("λ: ", saidas3[4])
